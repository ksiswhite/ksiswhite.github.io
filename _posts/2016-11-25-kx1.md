---
layout: post
title: "CTF:看雪CrackMe大赛第一题Write-up"
date:   2016-11-25
excerpt: "看雪CrackMe大赛第一题Write-up"
tag:
- Reverse
- CTF
---

<h2 id="-ctf-wu">看雪CTF 第一题WU</h2>
<p>程序由MFC编写，恰好最近在研究对MFC程序的逆向分析，正好作为一次练手。<br>本题存在多处反调试，放进OD后直接F9的话，无法弹出图形化界面。经过简单的分析，找出了如下2处反调试点。<br>第一处：<br>检测父进程是否为explorer，判断调试器。<br>入口为loc_0040C111→loc_0040C151→loc_00401340</p>
<blockquote>
<p>00111340  /&gt;  55            PUSH EBP<br>00111341  |.  8BEC          MOV EBP,ESP<br>00111343  |.  B8 244B0000   MOV EAX,4B24<br>00111348  |.  E8 035E0100   CALL 00127150<br>0011134D  |.  A1 14F01200   MOV EAX,DWORD PTR DS:[12F014]<br>00111352  |.  33C5          XOR EAX,EBP<br>00111354  |.  8945 FC       MOV DWORD PTR SS:[EBP-4],EAX<br>00111357  |.  53            PUSH EBX<br>00111358  |.  56            PUSH ESI<br>00111359  |.  57            PUSH EDI<br>0011135A  |.  E8 7F350000   CALL 001148DE                            ; [Crack_Me.001148DE<br>0011135F  |.  B9 88D91200   MOV ECX,OFFSET 0012D988                  ;<br>00111364  |.  E8 17FEFFFF   CALL 00111180                            ; [Crack_Me.00111180<br>00111369  |.  8BF0          MOV ESI,EAX<br>0011136B  |.  E8 10FDFFFF   CALL 00111080                            ; [Crack_Me.00111080<br>00111370  |.  8BF8          MOV EDI,EAX<br>00111372  |.  56            PUSH ESI                                 ; /Procname<br>00111373  |.  57            PUSH EDI                                 ; |/FileName<br>00111374  |.  FF15 54801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.LoadLibrar ; |KERNEL32.LoadLibraryW<br>0011137A  |.  50            PUSH EAX                                 ; |hModule<br>0011137B  |.  FF15 50801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetProcAdd ; KERNEL32.GetProcAddress<br>00111381  |.  8985 B0FDFFFF MOV DWORD PTR SS:[EBP-250],EAX<br>00111387  |.  FF15 5C801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.GetCurrent ;[KERNEL32.GetCurrentProcessId 在此处获取了当前进程的PID。<br>0011138D  |.  50            PUSH EAX                                 ; /ProcessID<br>0011138E  |.  6A 00         PUSH 0                                   ; |InheritHandle = FALSE<br>00111390  |.  68 FFFF1F00   PUSH 1FFFFF                              ; |Access = PROCESS_TERMINATE|PROCESS_CREATE_THREAD|PROCESS_SET_SESSIONID|PROCESS_VM_OPERATION|PROCESS_VM_READ|PROCESS_VM_WRITE|PROCESS_DUP_HANDLE|PROCESS_CREATE_PROCESS|PROCESS_SET_QUOTA|PROCESS_SET_INFORMATION|PROCESS_QUERY_INFORMATION|STANDARD_RIGHTS_REQ<br>00111395  |.  FF15 58801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.OpenProces ; KERNEL32.OpenProcess<br>0011139B  |.  56            PUSH ESI                                 ; /Arg1<br>0011139C  |.  8BD8          MOV EBX,EAX                              ; |<br>0011139E  |.  E8 3C190000   CALL 00112CDF                            ; Crack_Me.0011C93D<br>001113A3  |.  57            PUSH EDI                                 ; /Arg1<br>001113A4  |.  E8 36190000   CALL 00112CDF                            ; Crack_Me.0011C93D<br>001113A9  |.  83C4 08       ADD ESP,8<br>001113AC  |.  85DB          TEST EBX,EBX<br>001113AE  |.- 75 14         JNZ SHORT 001113C4<br>001113B0  |.  5F            POP EDI<br>001113B1  |.  5E            POP ESI<br>001113B2  |.  83C8 FF       OR EAX,FFFFFFFF<br>001113B5  |.  5B            POP EBX<br>001113B6  |.  8B4D FC       MOV ECX,DWORD PTR SS:[EBP-4]<br>001113B9  |.  33CD          XOR ECX,EBP<br>001113BB  |.  E8 05190000   CALL 00112CC5<br>001113C0  |.  8BE5          MOV ESP,EBP<br>001113C2  |.  5D            POP EBP<br>001113C3  |.  C3            RETN<br>001113C4  |&gt;  8D45 F8       LEA EAX,[EBP-8]<br>001113C7  |.  50            PUSH EAX<br>001113C8  |.  6A 18         PUSH 18<br>001113CA  |.  8D85 B4FDFFFF LEA EAX,[EBP-24C]<br>001113D0  |.  50            PUSH EAX<br>001113D1  |.  6A 00         PUSH 0<br>001113D3  |.  53            PUSH EBX<br>001113D4  |.  FF95 B0FDFFFF CALL DWORD PTR SS:[EBP-250]              ; 此处DWORD依靠loc_0011139E&amp;loc001113A4两函数拼接为ntdll.NtQueryInformationProcess，通过这个函数实现查询当前进程的父进程。<br>001113DA  |.  8B85 C8FDFFFF MOV EAX,DWORD PTR SS:[EBP-238]           ; 函数返回值中的父进程PID，此处为OD的PID。<br>001113E0  |.  53            PUSH EBX                                 ; /hObject<br>001113E1  |.  8985 ACFDFFFF MOV DWORD PTR SS:[EBP-254],EAX           ; |<br>001113E7  |.  FF15 60801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.CloseHandl ; KERNEL32.CloseHandle<br>001113ED  |.  E8 EC340000   CALL 001148DE                            ; [Crack_Me.001148DE<br>001113F2  |.  6A 00         PUSH 0                                   ; /ProcessID = 0 (0.)<br>001113F4  |.  6A 02         PUSH 2                                   ; |Flags = TH32CS_SNAPPROCESS<br>001113F6  |.  FF15 64801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.CreateTool ; KERNEL32.CreateToolhelp32Snapshot 获取进程列表的快照，用来进行PID查询<br>001113FC  |.  8BF8          MOV EDI,EAX<br>001113FE  |.  C785 CCFDFFFF MOV DWORD PTR SS:[EBP-234],22C<br>00111408  |.  68 28020000   PUSH 228                                 ; /Arg3 = 228<br>0011140D  |.  8D85 D0FDFFFF LEA EAX,[EBP-230]                        ; |<br>00111413  |.  89BD B0FDFFFF MOV DWORD PTR SS:[EBP-250],EDI           ; |<br>00111419  |.  6A 00         PUSH 0                                   ; |Arg2 = 0<br>0011141B  |.  50            PUSH EAX                                 ; |Arg1<br>0011141C  |.  E8 AF250000   CALL 001139D0                            ; Crack_Me.001139D0<br>00111421  |.  83C4 0C       ADD ESP,0C<br>00111424  |.  8D85 CCFDFFFF LEA EAX,[EBP-234]<br>0011142A  |.  50            PUSH EAX                                 ; /Arg2<br>0011142B  |.  57            PUSH EDI                                 ; |Arg1<br>0011142C  |.  FF15 68801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.Process32F ; kernel32.Process32FirstW<br>00111432  |.  8BF0          MOV ESI,EAX<br>00111434  |.  E8 07FEFFFF   CALL 00111240                            ; [Crack_Me.00111240 拼接explorer.exe字符串，并在下面的循环中，通过kernel32.Process32NextW查询explorer进程的PID<br>00111439  |.  8BD8          MOV EBX,EAX<br>0011143B  |.  85F6          TEST ESI,ESI<br>0011143D  |.- 74 6D         JZ SHORT 001114AC<br>0011143F  |.  8DBD DCB4FFFF LEA EDI,[EBP+FFFFB4DC]<br>00111445  |&gt;  85DB          /TEST EBX,EBX<br>00111447  |.- 74 46         |JZ SHORT 0011148F<br>00111449  |.  66:8B85 F0FDF |MOV AX,WORD PTR SS:[EBP-210]<br>00111450  |.  66:3B03       |CMP AX,WORD PTR DS:[EBX]<br>00111453  |.- 77 3A         |JA SHORT 0011148F<br>00111455  |.  8D85 F0FDFFFF |LEA EAX,[EBP-210]<br>0011145B  |.  8BF3          |MOV ESI,EBX<br>0011145D  |.  8BC8          |MOV ECX,EAX<br>0011145F  |.  2BF1          |SUB ESI,ECX<br>00111461  |&gt;  0FB71406      |/MOVZX EDX,WORD PTR DS:[EAX+ESI]<br>00111465  |.  0FB708        ||MOVZX ECX,WORD PTR DS:[EAX]<br>00111468  |.  66:3BCA       ||CMP CX,DX<br>0011146B  |.- 75 0A         ||JNE SHORT 00111477<br>0011146D  |.  66:85C9       ||TEST CX,CX<br>00111470  |.- 74 12         ||JZ SHORT 00111484<br>00111472  |.  83C0 02       ||ADD EAX,2<br>00111475  |.- EB 02         ||JMP SHORT 00111479<br>00111477  |&gt;- 72 16         ||JB SHORT 0011148F<br>00111479  |&gt;  66:8B08       ||MOV CX,WORD PTR DS:[EAX]<br>0011147C  |.  66:3B0C06     ||CMP CX,WORD PTR DS:[EAX+ESI]<br>00111480  |.- 76 DF         |JBE SHORT 00111461<br>00111482  |.- EB 0B         |JMP SHORT 0011148F<br>00111484  |&gt;  8B85 D4FDFFFF |MOV EAX,DWORD PTR SS:[EBP-22C]<br>0011148A  |.  8907          |MOV DWORD PTR DS:[EDI],EAX<br>0011148C  |.  83C7 04       |ADD EDI,4<br>0011148F  |&gt;  8D85 CCFDFFFF |LEA EAX,[EBP-234]<br>00111495  |.  50            |PUSH EAX                                ; /Arg2<br>00111496  |.  FFB5 B0FDFFFF |PUSH DWORD PTR SS:[EBP-250]             ; |Arg1<br>0011149C  |.  FF15 6C801200 |CALL DWORD PTR DS:[&lt;&amp;KERNEL32.Process32 ; kernel32.Process32NextW<br>001114A2  |.  85C0          |TEST EAX,EAX<br>001114A4  |.- 75 9F         JNZ SHORT 00111445                      ; 循环结束处，找到PID就不再跳回<br>001114A6  |.  8BBD B0FDFFFF MOV EDI,DWORD PTR SS:[EBP-250]           ; 将当前进程的PID与explorer的PID比较，如果父进程PID不符，即跳出，实现反调试。<br>001114AC  |&gt;  8B9D ACFDFFFF MOV EBX,DWORD PTR SS:[EBP-254]<br>001114B2  |.  BA 01000000   MOV EDX,1<br>001114B7  |.  3B9D DCB4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4DC]<br>001114BD  |.  8BCA          MOV ECX,EDX<br>001114BF  |.  0F94C0        SETE AL<br>001114C2  |.  3B9D E0B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4E0]<br>001114C8  |.  0FB6C0        MOVZX EAX,AL<br>001114CB  |.  0F44C2        CMOVE EAX,EDX<br>001114CE  |.  3B9D E4B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4E4]<br>001114D4  |.  0FB6C0        MOVZX EAX,AL<br>001114D7  |.  0F45C8        CMOVNE ECX,EAX<br>001114DA  |.  3B9D E8B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4E8]<br>001114E0  |.  0FB6C1        MOVZX EAX,CL<br>001114E3  |.  8BCA          MOV ECX,EDX<br>001114E5  |.  0F44C2        CMOVE EAX,EDX<br>001114E8  |.  3B9D ECB4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4EC]<br>001114EE  |.  0FB6C0        MOVZX EAX,AL<br>001114F1  |.  0F45C8        CMOVNE ECX,EAX<br>001114F4  |.  3B9D F0B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4F0]<br>001114FA  |.  0FB6C1        MOVZX EAX,CL<br>001114FD  |.  8BCA          MOV ECX,EDX<br>001114FF  |.  0F44C2        CMOVE EAX,EDX<br>00111502  |.  3B9D F4B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4F4]<br>00111508  |.  0FB6C0        MOVZX EAX,AL<br>0011150B  |.  0F45C8        CMOVNE ECX,EAX<br>0011150E  |.  3B9D F8B4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4F8]<br>00111514  |.  0FB6C1        MOVZX EAX,CL<br>00111517  |.  0F44C2        CMOVE EAX,EDX<br>0011151A  |.  3B9D FCB4FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB4FC]<br>00111520  |.  0FB6C0        MOVZX EAX,AL<br>00111523  |.  0F45D0        CMOVNE EDX,EAX<br>00111526  |.  3B9D 00B5FFFF CMP EBX,DWORD PTR SS:[EBP+FFFFB500]<br>0011152C  |.- 74 04         JE SHORT 00111532<br>0011152E  |.  84D2          TEST DL,DL<br>00111530      74 1A         JZ SHORT 0011154C                        ; 跳出，爆炸！<br>00111532  |&gt;  57            PUSH EDI                                 ; hObject<br>00111533  |.  FF15 60801200 CALL DWORD PTR DS:[&lt;&amp;KERNEL32.CloseHandl<br>00111539  |.  8B4D FC       MOV ECX,DWORD PTR SS:[EBP-4]<br>0011153C  |.  33C0          XOR EAX,EAX<br>0011153E  |.  5F            POP EDI<br>0011153F  |.  5E            POP ESI<br>00111540  |.  33CD          XOR ECX,EBP<br>00111542  |.  5B            POP EBX<br>00111543  |.  E8 7D170000   CALL 00112CC5<br>00111548  |.  8BE5          MOV ESP,EBP<br>0011154A  |.  5D            POP EBP<br>0011154B  |.  C3            RETN<br>0011154C  |&gt;  6A 00         PUSH 0<br>0011154E  \.  E8 5E360000   CALL 00114BB1</p>
</blockquote>
<p>解决方法，Patch loc_00111530处跳转为JMP SHOUT 00111532。</p>
<p>第二处:<br>检测时间差来判断调试器。<br>入口为sub_001148DE,该函数多次调用，检测点在loc_001115A2</p>
<blockquote>
<p>001115A2  |.  E8 37330000   CALL 013848DE                                                   ; [Crack_Me.013848DE<br>001115A7  |.  2BC7          SUB EAX,EDI<br>001115A9  |.  6A 00         PUSH 0                                                          ; /lParam = NULL<br>001115AB  |.  83F8 02       CMP EAX,2                                                       ; 判断001148DE返回值是否为小于2，也即时间差是否小于2。<br>001115AE  |.- 0F8F DA000000 JG 0138168E                                                     ; 跳到结束程序流程。</p>
</blockquote>
<p>解决方法，将sub_001148DE返回值改为0，此处可以有很多修改方法，我采用的方法是将函数最后的几个无用跳转改为<br>XOR EAX,EAX<br>NOP<br>实现返回0来过时间差判断。</p>
<p>过掉这两处反调试后，程序可以正常在OD中运行了。下面正式开始逆向工作。经过之前对于MFC程序的了解，所以我果断在DispatchMessage处下条件断点，监听按钮点击事件，通过spy++获取按钮句柄后，设置类似([[esp]]==003B05FC) &amp;&amp; ([[esp]+4]==202)这样的条件断电，[[esp]]处为按钮句柄。成功监听到按钮点击事件，但是在之后的发现从DispatchMessage之后，程序就在系统函数里到处跑，我就晕头转向跑不出来了，所以这里我并没有真正跟踪到DispatchMessage是如何跳转到下一步的。在此处，我在Log处发现程序新建了一个线程（多亏题目作者采用了多线程=。=不然可能我反而更麻烦。。），进入线程入口点下断，发现该线程即是真正对输入框进行判断的。</p>
<p>首先第一点发现是，按钮点击次数被带入了后续注册码运算，也即只能尝试一次，之后需重启程序。<br>慢慢跟进线程执行，逐个攻破判断。</p>
<p>首先，第一次判断是在loc_012D1C62</p>
<blockquote>
<p>00111C62   .  0FB7C9        MOVZX ECX,CX                                                    ; 输入<br>00111C65   .  BA 62000000   MOV EDX,62                                                      ;&#39;b&#39;<br>00111C70  /&gt;  66:3BD1       /CMP DX,CX<br>00111C73  |.- 74 1E         |JE SHORT 012D1C93                                              ; 跳转至错误流程<br>00111C75  |.  0FB78C45 36FF |MOVZX ECX,WORD PTR SS:[EAX*2+EBP-0CA]<br>00111C7D  |.  40            |INC EAX<br>00111C7E  |.  66:85C9       |TEST CX,CX<br>00111C81  |.- 75 ED         \JNZ SHORT 012D1C70</p>
</blockquote>
<p>很显然，这段代码在检验输入中是否有b这个字母。类似的紧随其后，程序又检验了是否有p这个字母。<br>接着，第三次判断是在loc_00111DE6</p>
<blockquote>
<p>00111DDF  |.  50            PUSH EAX                                 ; /Arg2 = 2<br>00111DE0  |.  53            PUSH EBX                                 ; |Arg1<br>00111DE1  |.  E8 8A0A0000   CALL 012D2870                            ; \Crack_Me.012D2870<br>00111DE6  |.  83FE 07       CMP ESI,7</p>
</blockquote>
<p>此处是在判断，输入注册码长度是否为7</p>
<p>第四处判断，是在loc_001119D7</p>
<blockquote>
<p>001119D7   .  8D45 F0       LEA EAX,[EBP-10]                         ; 此处为输入除去数字后的字符串<br>001119DA   .  66:394D F0    CMP WORD PTR SS:[EBP-10],CX<br>001119DE   .- 74 59         JE SHORT 00D81A39<br>001119E0   &gt;  8D40 02       LEA EAX,[EAX+2]<br>001119E3   .  41            INC ECX<br>001119E4   .  66:8338 00    CMP WORD PTR DS:[EAX],0<br>001119E8   .- 75 F6         JNE SHORT 00D819E0<br>001119EA   .  83F9 02       CMP ECX,2<br>001119ED   .-/75 4A         JNE SHORT 00D81A39                       ; 跳转至错误流程</p>
</blockquote>
<p>此处是在判断，输入注册码中，字母数量是否为2。</p>
<p>第五处判断，是在loc_001119EF</p>
<blockquote>
<p>001119EF   .  33C0          XOR EAX,EAX<br>001119F1   .  C745 F0 31003 MOV DWORD PTR SS:[EBP-10],350031         ; &#39;15&#39;<br>001119F8   .  C745 F4 50004 MOV DWORD PTR SS:[EBP-0C],420050         ; &#39;PB&#39;,注意：此处之前有大小写转换，所以输入为小写。<br>001119FF   .  8D77 04       LEA ESI,[EDI+4]<br>00111A02   .  66:8945 F8    MOV WORD PTR SS:[EBP-8],AX<br>00111A06   .  33C9          XOR ECX,ECX<br>00111A10  /&gt;  66:8B444D F0  /MOV AX,WORD PTR SS:[ECX*2+EBP-10]<br>00111A15  |.  66:3B06       |CMP AX,WORD PTR DS:[ESI]<br>00111A18  |.- 75 1F         |JNE SHORT 00D81A39<br>00111A1A  |.  41            |INC ECX<br>00111A1B  |.  83C6 02       |ADD ESI,2<br>00111A1E  |.  83F9 04       |CMP ECX,4<br>00111A21  |.- 72 ED         \JB SHORT 00D81A10</p>
</blockquote>
<p>此处是在判断，输入注册码的3-6位是否为15pb。</p>
<p>第六处判断，是在loc_001117D3</p>
<blockquote>
<p>001117D3  |&gt;  66:8B01       /MOV AX,WORD PTR DS:[ECX]                ; [ECX]中为123456789<br>001117D6  |.  66:C1E8 02    |SHR AX,2<br>001117DA  |.  66:03C7       |ADD AX,DI<br>001117DD  |.  66:83F8 32    |CMP AX,32<br>001117E1  |.- 74 78         |JE SHORT 00D8185B<br>001117E3  |.  66:83F8 64    |CMP AX,64<br>001117E7  |.- 74 0F         |JE SHORT 00D817F8<br>001117E9  |.  46            |INC ESI<br>001117EA  |.  8D4D DC       |LEA ECX,[EBP-24]<br>001117ED  |.  8D1436        |LEA EDX,[ESI+ESI]<br>001117F0  |.  03CA          |ADD ECX,EDX<br>001117F2  |.  66:8339 00    |CMP WORD PTR DS:[ECX],0<br>001117F6  |.- 75 DB         \JNE SHORT 00D817D3</p>
</blockquote>
<p>此处是在判断，输入注册码前两位是否为12。</p>
<p>最后一处判断是在loc_00111832</p>
<blockquote>
<p>00111832  |.  8B45 B4       MOV EAX,DWORD PTR SS:[EBP-4C]<br>00111835  |.  0FB74F 0C     MOVZX ECX,WORD PTR DS:[EDI+0C]<br>00111839  |.  0308          ADD ECX,DWORD PTR DS:[EAX]<br>0011183B  |.  8B45 B0       MOV EAX,DWORD PTR SS:[EBP-50]<br>0011183E  |.  0FB700        MOVZX EAX,WORD PTR DS:[EAX]<br>00111841  |.  3BC1          CMP EAX,ECX                              ; EAX为注册码的最后一位，ECX为&#39;8&#39;<br>00111843  |.- 75 16         JNE SHORT 0111185B</p>
</blockquote>
<p>此处是在判断，输入注册码最后一位是否为8。</p>
<p>至此，7位注册码均解出，最终答案为1215pb8。<br>本题逻辑不难，但判断条件很分散。</p>
<p>最后，哪位大神来给我讲讲MFC=。=？？？</p>
